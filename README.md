This package is written as a control platform to run trial-based experiments, by connecting different hardware and 
control them asynchronously, either using threads or multi-processes. It is aimed for a high-level interface, in which 
the user of the written experiments only need to interact with a very limited sets of commands, and the writer of the
experiments only need to implement these commands.

## Getting Started

### Installation
1. Setup environment

    The package comes with a .yml file, which specifies the dependencies of the program. It is suggested to create a new 
environment for the package. First download the .yml file, and then in the conda prompt, navigate to the folder where 
the downloaded file is located, and then create an environment with the file:
    ```
    conda env create -f slab_platform_env.yml
    ```
   
   You can also manually install all required packages listed in the .yml file.

2. Install hardware drivers (Optional)

    To use TDT hardware, the following external programs and packages need to be installed:
    * TDT drivers/RPvdsEx
    * TDT ActiveX
    * pywin32 (when using TDT's initialization code)

    To use the Photometrics Prime camera, the following external programs and packages need to be installed:
    * PVCAM (version 3.7.5.7)
    * PVCAM SDK (build 44, for PVCAM 3.7.3.3)
    * PyVCAM (custom version, https://bitbucket.org/sandriver/pyvcam_slab/src/master/; a C/C++ compiler is needed)

3. Install the slab_platform package
   ```
    pip install git+https://github.com/sandriver03/slab-platform.git
   ```


## Core ideas and classes

An experiment can be organized as a set of different hardwares and the logic of interactions among them. Therefore, in 
this toolbox, two main classes are defined:
1. The Device class, which defines the operation of hardware. Ideally one class for each individual hardware.
2. The ExperimentLogic class, which defines the logic of an experiment by operating different hardware at a correct 
sequence.

Lots of times, the Experiment/Devices need to be controlled asynchronously, i.e. the starting/pausing/resuming of the 
Experiment/Devices does not follow a pre-defined order, but rather need to be triggered by different events; parameters 
of Devices need to be modified while the Experiment is running. Also, most of time the data generated by the Devices 
need to be pulled and/or saved to storage (e.g. hard drive) constantly. Thus each Experiment/Device implements 
asynchronous control by either thread or subprocess. User can choose which method to use, or do not use any. 

It should be noted that these software-level asynchronous routines are not garanteed to be accurate in time - in a 
lightly loaded system they can achieve < 10 ms latencies, but anything faster than that will likely create jitters. 
Generally speaking, they should be used for not-so timing sensitive tasks (accuracy around 50 ms or longer). Timing 
critical tasks should be implemented by appropriate hardware, such as TDT or National Instrument devices.

Those two classes use similar state variables and commands. Important state variables are listed below:
1. state: 'Created', 'Initialized', 'Ready', 'Running', 'Paused' or 'Stopped'

The following commands are defined for all the classes:
1. initialize(): responsible for initializing hardware connections, setting up buffers, calculating intermediate 
parameters and so on. It prepares the Device/Experiment for running. Does not work when state is 'Running'.
2. configure(): used to change the parameters defined in Setting class. Each Device/Experiment class comes with 
corresponding Setting class, in which the parameters of the Device/Experiment class are defined.
3. start(): starts the Device/Experiment. Only works when state is 'Ready' or 'Paused'.
4. pause(): pauses the Device/Experiment. Only works when state is 'Running'.
5. stop(): stops the Device/Experiment by disconnecting the hardware, removing the buffers and so on. Stopped instances 
cannot be started again. Does not work when state is 'Running'.
6. reset(): performs a re-initialization. Does not work when state is 'Running'.

For the users of the written Device/Experiment classes, those commands should be sufficient. To write the 
Device/Experiment classes, the operation of those commands need to be implemented. See the provided examples for more 
details.

## Helper Classes
Other classes are provided to support the two main classes. Notably:
1. Setting class: defines parameters for each Device/Experiment class. Parameters defined in it are automatically saved 
when the *start* method of the Experiment class is called (this also include the parameters of all the Device classes 
involved in an Experiment class).
2. Data class: works with Experiment class and handles data from different devices. Currently supports in-memory and 
HDF5 data representation. Will automatically prepare data buffer based on the ._output_specs of each Device. Can be run 
in a separate thread/subprocess.
3. Stream (in Stream module): implements socket-based data transfer. OutputStream class defines a data source and 
InputStream class defines a data sink. Not necessary to use, but helps greatly when running Devices and/or Data class in
different threads/subprocesses.
4. Viewer (in GUI module): *matplotlib* based asynchronous data plotting utilities. Can be used to plot single channel 
time series (DataViewer class) or images (ImageViewer class). *matplotlib* is relatively slow, so running those classes 
in subprocess mode is advised.
5. Subject class: used to hold information about each experiment subject. Information in it will be automatically saved 
to experiment result by the Data class.


## Examples

### FooDevice
See `examples/Devices/FooDevice.py`, a simulated Device, which is a multichannel random number generator. A different 
version using the stream for communication can be seen in `examples/Devices/FooDevice_stream.py`

### FooExepriment
See `examples/Experiments/FooExperiment.py`, a simple experiment running a random number generator (`FooDevice`) with 
different parameters. A different version using asynchronous writer together with stream as data transfer can be seen in
`examples/Experiments/FooExp_SubprocessWriterTest.py`. Since the default `multiprocessing` package cannot pickle 
functions defined in `__main__`, to run the experiment use `examples/Experiments/run_FooExp_Subprocess.py`.

### ShamCam
See `examples/Devices/ShamCam.py`, a simulated camera. A `ImageView` from `GUI.View_subprocess` is used to monitor the 
generated frames in real time in a different process. Data are transferred between processes using `stream`.


## Documentation
See \build\html\index.html


## TODO list

5). `DataExplorer` in `core` need further work

6). only tested in Windows. probably need some change in the `config` module when used in other systems

7). a proper testing module

12). logging across thread/multiprocess

13). `Speaker` in the `utilities` need to be overhauled; integrate it with `SpeakerCalibration_config` in the `config` 
module

14). work on and test the GUI version of everything
